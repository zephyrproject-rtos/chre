// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_
#define FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace chre {
namespace fbs {

struct NanoappMessage;
struct NanoappMessageT;

struct HubInfoRequest;
struct HubInfoRequestT;

struct HubInfoResponse;
struct HubInfoResponseT;

struct NanoappListRequest;
struct NanoappListRequestT;

struct NanoappListEntry;
struct NanoappListEntryT;

struct NanoappListResponse;
struct NanoappListResponseT;

struct MessageContainer;
struct MessageContainerT;

/// A union that joins together all possible messages. Note that in FlatBuffers,
/// unions have an implicit type
enum class ChreMessage : uint8_t {
  NONE = 0,
  NanoappMessage = 1,
  HubInfoRequest = 2,
  HubInfoResponse = 3,
  NanoappListRequest = 4,
  NanoappListResponse = 5,
  MIN = NONE,
  MAX = NanoappListResponse
};

inline const char **EnumNamesChreMessage() {
  static const char *names[] = {
    "NONE",
    "NanoappMessage",
    "HubInfoRequest",
    "HubInfoResponse",
    "NanoappListRequest",
    "NanoappListResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameChreMessage(ChreMessage e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesChreMessage()[index];
}

template<typename T> struct ChreMessageTraits {
  static const ChreMessage enum_value = ChreMessage::NONE;
};

template<> struct ChreMessageTraits<NanoappMessage> {
  static const ChreMessage enum_value = ChreMessage::NanoappMessage;
};

template<> struct ChreMessageTraits<HubInfoRequest> {
  static const ChreMessage enum_value = ChreMessage::HubInfoRequest;
};

template<> struct ChreMessageTraits<HubInfoResponse> {
  static const ChreMessage enum_value = ChreMessage::HubInfoResponse;
};

template<> struct ChreMessageTraits<NanoappListRequest> {
  static const ChreMessage enum_value = ChreMessage::NanoappListRequest;
};

template<> struct ChreMessageTraits<NanoappListResponse> {
  static const ChreMessage enum_value = ChreMessage::NanoappListResponse;
};

struct ChreMessageUnion {
  ChreMessage type;
  flatbuffers::NativeTable *table;

  ChreMessageUnion() : type(ChreMessage::NONE), table(nullptr) {}
  ChreMessageUnion(ChreMessageUnion&& u):
    type(std::move(u.type)), table(std::move(u.table)) {}
  ChreMessageUnion(const ChreMessageUnion &);
  ChreMessageUnion &operator=(const ChreMessageUnion &);
  ~ChreMessageUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& value) {
    Reset();
    type = ChreMessageTraits<typename T::TableType>::enum_value;
    if (type != ChreMessage::NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  static flatbuffers::NativeTable *UnPack(const void *obj, ChreMessage type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  NanoappMessageT *AsNanoappMessage() {
    return type == ChreMessage::NanoappMessage ?
      reinterpret_cast<NanoappMessageT *>(table) : nullptr;
  }
  HubInfoRequestT *AsHubInfoRequest() {
    return type == ChreMessage::HubInfoRequest ?
      reinterpret_cast<HubInfoRequestT *>(table) : nullptr;
  }
  HubInfoResponseT *AsHubInfoResponse() {
    return type == ChreMessage::HubInfoResponse ?
      reinterpret_cast<HubInfoResponseT *>(table) : nullptr;
  }
  NanoappListRequestT *AsNanoappListRequest() {
    return type == ChreMessage::NanoappListRequest ?
      reinterpret_cast<NanoappListRequestT *>(table) : nullptr;
  }
  NanoappListResponseT *AsNanoappListResponse() {
    return type == ChreMessage::NanoappListResponse ?
      reinterpret_cast<NanoappListResponseT *>(table) : nullptr;
  }
};

bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type);
bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct NanoappMessageT : public flatbuffers::NativeTable {
  typedef NanoappMessage TableType;
  uint64_t app_id;
  uint32_t message_type;
  uint16_t host_endpoint;
  std::vector<uint8_t> message;
  NanoappMessageT()
      : app_id(0),
        message_type(0),
        host_endpoint(65534) {
  }
};

/// Represents a message sent to/from a nanoapp from/to a client on the host
struct NanoappMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappMessageT NativeTableType;
  enum {
    VT_APP_ID = 4,
    VT_MESSAGE_TYPE = 6,
    VT_HOST_ENDPOINT = 8,
    VT_MESSAGE = 10
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField(VT_APP_ID, _app_id);
  }
  uint32_t message_type() const {
    return GetField<uint32_t>(VT_MESSAGE_TYPE, 0);
  }
  bool mutate_message_type(uint32_t _message_type) {
    return SetField(VT_MESSAGE_TYPE, _message_type);
  }
  /// Identifies the host-side endpoint on the host that sent or should receive
  /// this message. The default value is a special value defined in the HAL and
  /// elsewhere that indicates that the endpoint is unspecified.
  uint16_t host_endpoint() const {
    return GetField<uint16_t>(VT_HOST_ENDPOINT, 65534);
  }
  bool mutate_host_endpoint(uint16_t _host_endpoint) {
    return SetField(VT_HOST_ENDPOINT, _host_endpoint);
  }
  /// Vector containing arbitrary application-specific message data
  const flatbuffers::Vector<uint8_t> *message() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MESSAGE);
  }
  flatbuffers::Vector<uint8_t> *mutable_message() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_HOST_ENDPOINT) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
  NanoappMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappMessage::VT_APP_ID, app_id, 0);
  }
  void add_message_type(uint32_t message_type) {
    fbb_.AddElement<uint32_t>(NanoappMessage::VT_MESSAGE_TYPE, message_type, 0);
  }
  void add_host_endpoint(uint16_t host_endpoint) {
    fbb_.AddElement<uint16_t>(NanoappMessage::VT_HOST_ENDPOINT, host_endpoint, 65534);
  }
  void add_message(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message) {
    fbb_.AddOffset(NanoappMessage::VT_MESSAGE, message);
  }
  NanoappMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappMessageBuilder &operator=(const NanoappMessageBuilder &);
  flatbuffers::Offset<NanoappMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<NanoappMessage>(end);
    fbb_.Required(o, NanoappMessage::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t message_type = 0,
    uint16_t host_endpoint = 65534,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message = 0) {
  NanoappMessageBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  builder_.add_host_endpoint(host_endpoint);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t message_type = 0,
    uint16_t host_endpoint = 65534,
    const std::vector<uint8_t> *message = nullptr) {
  return chre::fbs::CreateNanoappMessage(
      _fbb,
      app_id,
      message_type,
      host_endpoint,
      message ? _fbb.CreateVector<uint8_t>(*message) : 0);
}

flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HubInfoRequestT : public flatbuffers::NativeTable {
  typedef HubInfoRequest TableType;
  HubInfoRequestT() {
  }
};

struct HubInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HubInfoRequestT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HubInfoRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HubInfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HubInfoRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HubInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  HubInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HubInfoRequestBuilder &operator=(const HubInfoRequestBuilder &);
  flatbuffers::Offset<HubInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<HubInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HubInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HubInfoResponseT : public flatbuffers::NativeTable {
  typedef HubInfoResponse TableType;
  std::vector<int8_t> name;
  std::vector<int8_t> vendor;
  std::vector<int8_t> toolchain;
  uint32_t platform_version;
  uint32_t toolchain_version;
  float peak_mips;
  float stopped_power;
  float sleep_power;
  float peak_power;
  uint32_t max_msg_len;
  uint64_t platform_id;
  uint32_t chre_platform_version;
  HubInfoResponseT()
      : platform_version(0),
        toolchain_version(0),
        peak_mips(0.0f),
        stopped_power(0.0f),
        sleep_power(0.0f),
        peak_power(0.0f),
        max_msg_len(0),
        platform_id(0),
        chre_platform_version(0) {
  }
};

struct HubInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HubInfoResponseT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_VENDOR = 6,
    VT_TOOLCHAIN = 8,
    VT_PLATFORM_VERSION = 10,
    VT_TOOLCHAIN_VERSION = 12,
    VT_PEAK_MIPS = 14,
    VT_STOPPED_POWER = 16,
    VT_SLEEP_POWER = 18,
    VT_PEAK_POWER = 20,
    VT_MAX_MSG_LEN = 22,
    VT_PLATFORM_ID = 24,
    VT_CHRE_PLATFORM_VERSION = 26
  };
  /// The name of the hub. Nominally a UTF-8 string, but note that we're not
  /// using the built-in "string" data type from FlatBuffers here, because the
  /// generated C++ uses std::string which is not well-supported in CHRE. This
  /// applies for vendor and toolchain as well.
  const flatbuffers::Vector<int8_t> *name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  const flatbuffers::Vector<int8_t> *vendor() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VENDOR);
  }
  flatbuffers::Vector<int8_t> *mutable_vendor() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_VENDOR);
  }
  const flatbuffers::Vector<int8_t> *toolchain() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TOOLCHAIN);
  }
  flatbuffers::Vector<int8_t> *mutable_toolchain() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_TOOLCHAIN);
  }
  /// Legacy platform version reported in the HAL; semantics not strictly
  /// defined
  uint32_t platform_version() const {
    return GetField<uint32_t>(VT_PLATFORM_VERSION, 0);
  }
  bool mutate_platform_version(uint32_t _platform_version) {
    return SetField(VT_PLATFORM_VERSION, _platform_version);
  }
  /// Toolchain version reported in the HAL; semantics not strictly defined
  uint32_t toolchain_version() const {
    return GetField<uint32_t>(VT_TOOLCHAIN_VERSION, 0);
  }
  bool mutate_toolchain_version(uint32_t _toolchain_version) {
    return SetField(VT_TOOLCHAIN_VERSION, _toolchain_version);
  }
  float peak_mips() const {
    return GetField<float>(VT_PEAK_MIPS, 0.0f);
  }
  bool mutate_peak_mips(float _peak_mips) {
    return SetField(VT_PEAK_MIPS, _peak_mips);
  }
  float stopped_power() const {
    return GetField<float>(VT_STOPPED_POWER, 0.0f);
  }
  bool mutate_stopped_power(float _stopped_power) {
    return SetField(VT_STOPPED_POWER, _stopped_power);
  }
  float sleep_power() const {
    return GetField<float>(VT_SLEEP_POWER, 0.0f);
  }
  bool mutate_sleep_power(float _sleep_power) {
    return SetField(VT_SLEEP_POWER, _sleep_power);
  }
  float peak_power() const {
    return GetField<float>(VT_PEAK_POWER, 0.0f);
  }
  bool mutate_peak_power(float _peak_power) {
    return SetField(VT_PEAK_POWER, _peak_power);
  }
  /// Maximum size message that can be sent to a nanoapp
  uint32_t max_msg_len() const {
    return GetField<uint32_t>(VT_MAX_MSG_LEN, 0);
  }
  bool mutate_max_msg_len(uint32_t _max_msg_len) {
    return SetField(VT_MAX_MSG_LEN, _max_msg_len);
  }
  /// @see chreGetPlatformId()
  uint64_t platform_id() const {
    return GetField<uint64_t>(VT_PLATFORM_ID, 0);
  }
  bool mutate_platform_id(uint64_t _platform_id) {
    return SetField(VT_PLATFORM_ID, _platform_id);
  }
  /// @see chreGetVersion()
  uint32_t chre_platform_version() const {
    return GetField<uint32_t>(VT_CHRE_PLATFORM_VERSION, 0);
  }
  bool mutate_chre_platform_version(uint32_t _chre_platform_version) {
    return SetField(VT_CHRE_PLATFORM_VERSION, _chre_platform_version);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VENDOR) &&
           verifier.Verify(vendor()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TOOLCHAIN) &&
           verifier.Verify(toolchain()) &&
           VerifyField<uint32_t>(verifier, VT_PLATFORM_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_TOOLCHAIN_VERSION) &&
           VerifyField<float>(verifier, VT_PEAK_MIPS) &&
           VerifyField<float>(verifier, VT_STOPPED_POWER) &&
           VerifyField<float>(verifier, VT_SLEEP_POWER) &&
           VerifyField<float>(verifier, VT_PEAK_POWER) &&
           VerifyField<uint32_t>(verifier, VT_MAX_MSG_LEN) &&
           VerifyField<uint64_t>(verifier, VT_PLATFORM_ID) &&
           VerifyField<uint32_t>(verifier, VT_CHRE_PLATFORM_VERSION) &&
           verifier.EndTable();
  }
  HubInfoResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HubInfoResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HubInfoResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HubInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> name) {
    fbb_.AddOffset(HubInfoResponse::VT_NAME, name);
  }
  void add_vendor(flatbuffers::Offset<flatbuffers::Vector<int8_t>> vendor) {
    fbb_.AddOffset(HubInfoResponse::VT_VENDOR, vendor);
  }
  void add_toolchain(flatbuffers::Offset<flatbuffers::Vector<int8_t>> toolchain) {
    fbb_.AddOffset(HubInfoResponse::VT_TOOLCHAIN, toolchain);
  }
  void add_platform_version(uint32_t platform_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_PLATFORM_VERSION, platform_version, 0);
  }
  void add_toolchain_version(uint32_t toolchain_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_TOOLCHAIN_VERSION, toolchain_version, 0);
  }
  void add_peak_mips(float peak_mips) {
    fbb_.AddElement<float>(HubInfoResponse::VT_PEAK_MIPS, peak_mips, 0.0f);
  }
  void add_stopped_power(float stopped_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_STOPPED_POWER, stopped_power, 0.0f);
  }
  void add_sleep_power(float sleep_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_SLEEP_POWER, sleep_power, 0.0f);
  }
  void add_peak_power(float peak_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_PEAK_POWER, peak_power, 0.0f);
  }
  void add_max_msg_len(uint32_t max_msg_len) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_MAX_MSG_LEN, max_msg_len, 0);
  }
  void add_platform_id(uint64_t platform_id) {
    fbb_.AddElement<uint64_t>(HubInfoResponse::VT_PLATFORM_ID, platform_id, 0);
  }
  void add_chre_platform_version(uint32_t chre_platform_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_CHRE_PLATFORM_VERSION, chre_platform_version, 0);
  }
  HubInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HubInfoResponseBuilder &operator=(const HubInfoResponseBuilder &);
  flatbuffers::Offset<HubInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 12);
    auto o = flatbuffers::Offset<HubInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> vendor = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> toolchain = 0,
    uint32_t platform_version = 0,
    uint32_t toolchain_version = 0,
    float peak_mips = 0.0f,
    float stopped_power = 0.0f,
    float sleep_power = 0.0f,
    float peak_power = 0.0f,
    uint32_t max_msg_len = 0,
    uint64_t platform_id = 0,
    uint32_t chre_platform_version = 0) {
  HubInfoResponseBuilder builder_(_fbb);
  builder_.add_platform_id(platform_id);
  builder_.add_chre_platform_version(chre_platform_version);
  builder_.add_max_msg_len(max_msg_len);
  builder_.add_peak_power(peak_power);
  builder_.add_sleep_power(sleep_power);
  builder_.add_stopped_power(stopped_power);
  builder_.add_peak_mips(peak_mips);
  builder_.add_toolchain_version(toolchain_version);
  builder_.add_platform_version(platform_version);
  builder_.add_toolchain(toolchain);
  builder_.add_vendor(vendor);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *name = nullptr,
    const std::vector<int8_t> *vendor = nullptr,
    const std::vector<int8_t> *toolchain = nullptr,
    uint32_t platform_version = 0,
    uint32_t toolchain_version = 0,
    float peak_mips = 0.0f,
    float stopped_power = 0.0f,
    float sleep_power = 0.0f,
    float peak_power = 0.0f,
    uint32_t max_msg_len = 0,
    uint64_t platform_id = 0,
    uint32_t chre_platform_version = 0) {
  return chre::fbs::CreateHubInfoResponse(
      _fbb,
      name ? _fbb.CreateVector<int8_t>(*name) : 0,
      vendor ? _fbb.CreateVector<int8_t>(*vendor) : 0,
      toolchain ? _fbb.CreateVector<int8_t>(*toolchain) : 0,
      platform_version,
      toolchain_version,
      peak_mips,
      stopped_power,
      sleep_power,
      peak_power,
      max_msg_len,
      platform_id,
      chre_platform_version);
}

flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListRequestT : public flatbuffers::NativeTable {
  typedef NanoappListRequest TableType;
  NanoappListRequestT() {
  }
};

struct NanoappListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListRequestT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NanoappListRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  NanoappListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListRequestBuilder &operator=(const NanoappListRequestBuilder &);
  flatbuffers::Offset<NanoappListRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<NanoappListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NanoappListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListEntryT : public flatbuffers::NativeTable {
  typedef NanoappListEntry TableType;
  uint64_t app_id;
  uint32_t version;
  bool enabled;
  bool is_system;
  NanoappListEntryT()
      : app_id(0),
        version(0),
        enabled(true),
        is_system(false) {
  }
};

struct NanoappListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListEntryT NativeTableType;
  enum {
    VT_APP_ID = 4,
    VT_VERSION = 6,
    VT_ENABLED = 8,
    VT_IS_SYSTEM = 10
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField(VT_APP_ID, _app_id);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField(VT_VERSION, _version);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 1) != 0;
  }
  bool mutate_enabled(bool _enabled) {
    return SetField(VT_ENABLED, static_cast<uint8_t>(_enabled));
  }
  /// Whether the nanoapp is a pre-loaded "system" nanoapp, i.e. one that should
  /// not show up in the list of nanoapps in the context hub HAL. System
  /// nanoapps are typically used to leverage CHRE for some device functionality
  /// and do not interact via the context hub HAL.
  bool is_system() const {
    return GetField<uint8_t>(VT_IS_SYSTEM, 0) != 0;
  }
  bool mutate_is_system(bool _is_system) {
    return SetField(VT_IS_SYSTEM, static_cast<uint8_t>(_is_system));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYSTEM) &&
           verifier.EndTable();
  }
  NanoappListEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappListEntry::VT_APP_ID, app_id, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(NanoappListEntry::VT_VERSION, version, 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(NanoappListEntry::VT_ENABLED, static_cast<uint8_t>(enabled), 1);
  }
  void add_is_system(bool is_system) {
    fbb_.AddElement<uint8_t>(NanoappListEntry::VT_IS_SYSTEM, static_cast<uint8_t>(is_system), 0);
  }
  NanoappListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListEntryBuilder &operator=(const NanoappListEntryBuilder &);
  flatbuffers::Offset<NanoappListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<NanoappListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t version = 0,
    bool enabled = true,
    bool is_system = false) {
  NanoappListEntryBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_version(version);
  builder_.add_is_system(is_system);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListResponseT : public flatbuffers::NativeTable {
  typedef NanoappListResponse TableType;
  std::vector<std::unique_ptr<NanoappListEntryT>> nanoapps;
  NanoappListResponseT() {
  }
};

struct NanoappListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListResponseT NativeTableType;
  enum {
    VT_NANOAPPS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<NanoappListEntry>> *nanoapps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NanoappListEntry>> *>(VT_NANOAPPS);
  }
  flatbuffers::Vector<flatbuffers::Offset<NanoappListEntry>> *mutable_nanoapps() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<NanoappListEntry>> *>(VT_NANOAPPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NANOAPPS) &&
           verifier.Verify(nanoapps()) &&
           verifier.VerifyVectorOfTables(nanoapps()) &&
           verifier.EndTable();
  }
  NanoappListResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nanoapps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NanoappListEntry>>> nanoapps) {
    fbb_.AddOffset(NanoappListResponse::VT_NANOAPPS, nanoapps);
  }
  NanoappListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListResponseBuilder &operator=(const NanoappListResponseBuilder &);
  flatbuffers::Offset<NanoappListResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<NanoappListResponse>(end);
    fbb_.Required(o, NanoappListResponse::VT_NANOAPPS);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NanoappListEntry>>> nanoapps = 0) {
  NanoappListResponseBuilder builder_(_fbb);
  builder_.add_nanoapps(nanoapps);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NanoappListEntry>> *nanoapps = nullptr) {
  return chre::fbs::CreateNanoappListResponse(
      _fbb,
      nanoapps ? _fbb.CreateVector<flatbuffers::Offset<NanoappListEntry>>(*nanoapps) : 0);
}

flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageContainerT : public flatbuffers::NativeTable {
  typedef MessageContainer TableType;
  ChreMessageUnion message;
  MessageContainerT() {
  }
};

/// The top-level container that encapsulates all possible messages. Note that
/// per FlatBuffers requirements, we can't use a union as the top-level structure
/// (root type), so we must wrap it in a table.
struct MessageContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageContainerT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  ChreMessage message_type() const {
    return static_cast<ChreMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(ChreMessage _message_type) {
    return SetField(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyChreMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  MessageContainerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageContainerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageContainer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MessageContainerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(ChreMessage message_type) {
    fbb_.AddElement<uint8_t>(MessageContainer::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(MessageContainer::VT_MESSAGE, message);
  }
  MessageContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageContainerBuilder &operator=(const MessageContainerBuilder &);
  flatbuffers::Offset<MessageContainer> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MessageContainer>(end);
    fbb_.Required(o, MessageContainer::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<MessageContainer> CreateMessageContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    ChreMessage message_type = ChreMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageContainerBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageContainer> CreateMessageContainer(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NanoappMessageT *NanoappMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NanoappMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NanoappMessage::UnPackTo(NanoappMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_id(); _o->app_id = _e; };
  { auto _e = message_type(); _o->message_type = _e; };
  { auto _e = host_endpoint(); _o->host_endpoint = _e; };
  { auto _e = message(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->message.push_back(_e->Get(_i)); } };
}

inline flatbuffers::Offset<NanoappMessage> NanoappMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _app_id = _o->app_id;
  auto _message_type = _o->message_type;
  auto _host_endpoint = _o->host_endpoint;
  auto _message = _fbb.CreateVector(_o->message);
  return chre::fbs::CreateNanoappMessage(
      _fbb,
      _app_id,
      _message_type,
      _host_endpoint,
      _message);
}

inline HubInfoRequestT *HubInfoRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HubInfoRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HubInfoRequest::UnPackTo(HubInfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HubInfoRequest> HubInfoRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHubInfoRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return chre::fbs::CreateHubInfoRequest(
      _fbb);
}

inline HubInfoResponseT *HubInfoResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HubInfoResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HubInfoResponse::UnPackTo(HubInfoResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name.push_back(_e->Get(_i)); } };
  { auto _e = vendor(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vendor.push_back(_e->Get(_i)); } };
  { auto _e = toolchain(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->toolchain.push_back(_e->Get(_i)); } };
  { auto _e = platform_version(); _o->platform_version = _e; };
  { auto _e = toolchain_version(); _o->toolchain_version = _e; };
  { auto _e = peak_mips(); _o->peak_mips = _e; };
  { auto _e = stopped_power(); _o->stopped_power = _e; };
  { auto _e = sleep_power(); _o->sleep_power = _e; };
  { auto _e = peak_power(); _o->peak_power = _e; };
  { auto _e = max_msg_len(); _o->max_msg_len = _e; };
  { auto _e = platform_id(); _o->platform_id = _e; };
  { auto _e = chre_platform_version(); _o->chre_platform_version = _e; };
}

inline flatbuffers::Offset<HubInfoResponse> HubInfoResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHubInfoResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _o->name.size() ? _fbb.CreateVector(_o->name) : 0;
  auto _vendor = _o->vendor.size() ? _fbb.CreateVector(_o->vendor) : 0;
  auto _toolchain = _o->toolchain.size() ? _fbb.CreateVector(_o->toolchain) : 0;
  auto _platform_version = _o->platform_version;
  auto _toolchain_version = _o->toolchain_version;
  auto _peak_mips = _o->peak_mips;
  auto _stopped_power = _o->stopped_power;
  auto _sleep_power = _o->sleep_power;
  auto _peak_power = _o->peak_power;
  auto _max_msg_len = _o->max_msg_len;
  auto _platform_id = _o->platform_id;
  auto _chre_platform_version = _o->chre_platform_version;
  return chre::fbs::CreateHubInfoResponse(
      _fbb,
      _name,
      _vendor,
      _toolchain,
      _platform_version,
      _toolchain_version,
      _peak_mips,
      _stopped_power,
      _sleep_power,
      _peak_power,
      _max_msg_len,
      _platform_id,
      _chre_platform_version);
}

inline NanoappListRequestT *NanoappListRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NanoappListRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NanoappListRequest::UnPackTo(NanoappListRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NanoappListRequest> NanoappListRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return chre::fbs::CreateNanoappListRequest(
      _fbb);
}

inline NanoappListEntryT *NanoappListEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NanoappListEntryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NanoappListEntry::UnPackTo(NanoappListEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_id(); _o->app_id = _e; };
  { auto _e = version(); _o->version = _e; };
  { auto _e = enabled(); _o->enabled = _e; };
  { auto _e = is_system(); _o->is_system = _e; };
}

inline flatbuffers::Offset<NanoappListEntry> NanoappListEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _app_id = _o->app_id;
  auto _version = _o->version;
  auto _enabled = _o->enabled;
  auto _is_system = _o->is_system;
  return chre::fbs::CreateNanoappListEntry(
      _fbb,
      _app_id,
      _version,
      _enabled,
      _is_system);
}

inline NanoappListResponseT *NanoappListResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NanoappListResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NanoappListResponse::UnPackTo(NanoappListResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nanoapps(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nanoapps.push_back(std::unique_ptr<NanoappListEntryT>(_e->Get(_i)->UnPack(_resolver))); } };
}

inline flatbuffers::Offset<NanoappListResponse> NanoappListResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _nanoapps = _fbb.CreateVector<flatbuffers::Offset<NanoappListEntry>>(_o->nanoapps.size(), [&](size_t i) { return CreateNanoappListEntry(_fbb, _o->nanoapps[i].get(), _rehasher); });
  return chre::fbs::CreateNanoappListResponse(
      _fbb,
      _nanoapps);
}

inline MessageContainerT *MessageContainer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageContainerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MessageContainer::UnPackTo(MessageContainerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.table = ChreMessageUnion::UnPack(_e, message_type(),_resolver); };
}

inline flatbuffers::Offset<MessageContainer> MessageContainer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageContainer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageContainer> CreateMessageContainer(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return chre::fbs::CreateMessageContainer(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type) {
  switch (type) {
    case ChreMessage::NONE: {
      return true;
    }
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const NanoappMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const HubInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const HubInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const NanoappListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const NanoappListResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyChreMessage(
        verifier,  values->Get(i), types->GetEnum<ChreMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline flatbuffers::NativeTable *ChreMessageUnion::UnPack(const void *obj, ChreMessage type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const NanoappMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const HubInfoRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const HubInfoResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const NanoappListRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const NanoappListResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ChreMessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const NanoappMessageT *>(table);
      return CreateNanoappMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const HubInfoRequestT *>(table);
      return CreateHubInfoRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const HubInfoResponseT *>(table);
      return CreateHubInfoResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const NanoappListRequestT *>(table);
      return CreateNanoappListRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const NanoappListResponseT *>(table);
      return CreateNanoappListResponse(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline void ChreMessageUnion::Reset() {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<NanoappMessageT *>(table);
      delete ptr;
      break;
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<HubInfoRequestT *>(table);
      delete ptr;
      break;
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<HubInfoResponseT *>(table);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<NanoappListRequestT *>(table);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<NanoappListResponseT *>(table);
      delete ptr;
      break;
    }
    default: break;
  }
  table = nullptr;
  type = ChreMessage::NONE;
}

inline const chre::fbs::MessageContainer *GetMessageContainer(const void *buf) {
  return flatbuffers::GetRoot<chre::fbs::MessageContainer>(buf);
}

inline MessageContainer *GetMutableMessageContainer(void *buf) {
  return flatbuffers::GetMutableRoot<MessageContainer>(buf);
}

inline bool VerifyMessageContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<chre::fbs::MessageContainer>(nullptr);
}

inline void FinishMessageContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chre::fbs::MessageContainer> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<MessageContainerT> UnPackMessageContainer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageContainerT>(GetMessageContainer(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace chre

#endif  // FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_
